The Sensor Data XEP is a protocol to read the field values that a node [node footnote] may have. The main goals of the Sensor XEP are transparency and compatibility with Control. Since the Sensor Data XEP is the mediator between a client and a node regarding it`s information, Sensor Data is designed to tell the client any and all needed information. Being mediator also implies interaction with the Control XEP, since control exists to set the values of a node.\\
It is important to note the differences between a field value and a control parameter. When the `knobs` of a node are set through the Control XEP, the knobs are the control parameters. When the knobs of a node are being observed through the Sensor Data XEP, the knobs are called fields, by convention. A node`s control parameters are a subset of its fields (which are controllable). The reason for this is that a node may have fields that should not or cannot be set. The Universal Product Code (UPC) of a product is an example of a field that should not be altered. A field may carry a `controllable` flag, but use of this flag is optional. \\
Field values also have slightly different data types than control parameters. The main difference is that Sensor Data has enumeration and numeric data types, which are not available data types in control. The idea behind avoiding enumerations in the Control XEP is that leaving values as strings allows developers the liberty to use units as desired, seeing as a complete set of field names and units is difficult to achieve for any value. However, enums are allowed inside of a device through Sensor Data because XML validation is difficult with free strings and consumers of sensor data need to include unit conversion algorithms. \\
The numeric data type represents a numerical number with an implicit precision and an optional unit. This is for something like temperature...where the numeric variable would be 10 degrees Celsius which is different than 10.0 degrees Celsius in terms of precision. The idea behind avoiding numerics in the Control XEP is that a controller is not assumed to understand how to convert units. \\
Since Sensor Data aims to be completely transparent about a node`s information, a field carries two optional attribute groups. One attribute group is the field`s types which are not to be confused with a fields value types. Field types is a collection of flags that can convey information regarding a specific field that would be useful to a client, such as how long ago the value was set. The flags also include information for if a value can be used for identification, if it`s measured at the time of read-out (or momentary), if it displays status information, if it`s at its peak value, and if it`s computed rather than measured. The other attribute group that a field may carry is it`s quality of service values. These values are also flags that can convey useful information such as the field value not being set, being in progress of measurement, if it`s automatically estimated, whether a warning or error was logged during the measurement period, etc.\\
Like Control, Sensor Data has it`s own version of the getForm command. This is the `all` flag that can be set in a read-out request. This is different than Control in that all fields will be shown, not just those that can be controlled. A sample of this read-out request is above in Figure 2.\\
\begin{figure}
\lstinputlisting[breaklines=true, numbers=left, frame=single, stepnumber=1]{stanzas/getAll.xml}
\caption{A sample Sensor Data read-out request}
\end{figure}
Since fields have a writable attribute, Sensor Data can be queried to deliver all writeable data. This displays the current control state, just like getForm. Since a node may support both Control and Sensor Data XEPs, it may be holding a value that has a data type that is only included in sensor data. A complete conversion table is laid out in XEP-0325 in this case. The most important mappings are that enums map to strings, and numeric values are simply truncated unless converted to a double (units and precision are lost).\\
A client can also query for specific field types. Especially useful for IoT is the ability to query for momentary values, or values that are measured at run-time of the query. This is useful in that momentary values do not need to be subscribed to, as in a publish/subscribe architecture. The client can simply request a readout of momentary values whenever it feels the need to do so. Clients can optionally set `to` and `from` parameter values, specifying a time range of when the returned values should have been set.\\
Requests always come equipped with the client`s sequence number that requested the data as shown above in Figure 2. Clients pick their sequence number upon their first request. If a request is accepted, the device sends an accepted message and adds the client`s sequence number and request information in a queue. After reading the necessary data, the client then responds with the fields requested if possible, or an error. The client then concludes the interaction with a close message. A use case diagram is in the appendix.
